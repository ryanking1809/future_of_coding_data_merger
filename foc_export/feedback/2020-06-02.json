[
    {
        "client_msg_id": "e8defb10-018d-45a8-9994-0056471ba32f",
        "type": "message",
        "text": "<@U0143PC0UTC> it's a generative model, end goal is code -&gt; picture that represents that code",
        "user": "UQPHR6Y3S",
        "ts": "1591107593.266900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "072ed9b65c97",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-09\/890538367777_072ed9b65c977f61e33b_72.jpg",
            "first_name": "noahtren",
            "real_name": "noahtren",
            "display_name": "noahtren",
            "team": "T5TCAFTA9",
            "name": "noahtren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j1m0h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0143PC0UTC"
                            },
                            {
                                "type": "text",
                                "text": " it's a generative model, end goal is code -> picture that represents that code"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591039501.266000",
        "parent_user_id": "UQPHR6Y3S"
    },
    {
        "client_msg_id": "5b5341a1-45d5-4cc3-ac80-7aaab5e8691a",
        "type": "message",
        "text": "As somebody familiar with the transformation taking place, what do you see when you look at that interpolation? I have a hard time parsing meaning out of it.",
        "user": "UKDM3GLAJ",
        "ts": "1591109326.267100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "34e7a55348e8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-04\/893378739792_34e7a55348e8c86c1901_72.jpg",
            "first_name": "",
            "real_name": "Jared Windover",
            "display_name": "Jared Windover",
            "team": "T5TCAFTA9",
            "name": "jaredwindover",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N382",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As somebody familiar with the transformation taking place, what do you see when you look at that interpolation? I have a hard time parsing meaning out of it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591039501.266000",
        "parent_user_id": "UQPHR6Y3S"
    },
    {
        "client_msg_id": "6b3290ff-9faf-4f27-979c-a616b2cad47a",
        "type": "message",
        "text": "<@UKDM3GLAJ> it's actually unfamiliar to me as well! I basically set up the constraints and it generates a solution without any guidance. I haven't dug into this one yet to try finding any patterns. If I were to guess on this one, it looks like the region on the left describes different operations while the patterns on the right are staying mostly constant. I'm interpolating between `a ?? b` where ?? is different operands like + - * \/",
        "user": "UQPHR6Y3S",
        "ts": "1591122362.267300",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "072ed9b65c97",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-09\/890538367777_072ed9b65c977f61e33b_72.jpg",
            "first_name": "noahtren",
            "real_name": "noahtren",
            "display_name": "noahtren",
            "team": "T5TCAFTA9",
            "name": "noahtren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ihkv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " it's actually unfamiliar to me as well! I basically set up the constraints and it generates a solution without any guidance. I haven't dug into this one yet to try finding any patterns. If I were to guess on this one, it looks like the region on the left describes different operations while the patterns on the right are staying mostly constant. I'm interpolating between "
                            },
                            {
                                "type": "text",
                                "text": "a ?? b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " where ?? is different operands like + - * \/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591039501.266000",
        "parent_user_id": "UQPHR6Y3S",
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "242f0ab5-0e0a-462f-adc6-d9b0c909eb7e",
        "type": "message",
        "text": "What are the constraints?",
        "user": "UKDM3GLAJ",
        "ts": "1591122448.267500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "34e7a55348e8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-04\/893378739792_34e7a55348e8c86c1901_72.jpg",
            "first_name": "",
            "real_name": "Jared Windover",
            "display_name": "Jared Windover",
            "team": "T5TCAFTA9",
            "name": "jaredwindover",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dd4Cp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are the constraints?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591039501.266000",
        "parent_user_id": "UQPHR6Y3S"
    },
    {
        "client_msg_id": "73f8356a-9e43-4e51-b97c-412cb4850ce6",
        "type": "message",
        "text": "<@UKDM3GLAJ> constraints essentially being the loss function and design of the neural network. the big constraint I'm designing for is isomorphism, so a+b and b+a are represented in the same way, which I'm doing with a graph neural network",
        "user": "UQPHR6Y3S",
        "ts": "1591124356.281600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "072ed9b65c97",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-01-09\/890538367777_072ed9b65c977f61e33b_72.jpg",
            "first_name": "noahtren",
            "real_name": "noahtren",
            "display_name": "noahtren",
            "team": "T5TCAFTA9",
            "name": "noahtren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9\/DD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " constraints essentially being the loss function and design of the neural network. the big constraint I'm designing for is isomorphism, so a+b and b+a are represented in the same way, which I'm doing with a graph neural network"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591039501.266000",
        "parent_user_id": "UQPHR6Y3S",
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "796953B6-2674-4DF9-BB41-E8B6C0887F6C",
        "type": "message",
        "text": "A few comments on this thread.\n1. This presentation ignores a lot of research on visual programming languages. Specifically there is a large focus in current computing education research on transitioning from a visual language to a text based one gradually (some with real quant and qual behind them)\n2. Haskell’s currying exists because all functions take a single argument. But if you wanted to address the issue you mention, you could color each “type” in the signature and show the result under the type variable (with parens as boxes) so you can keep track (like rainbow paren for LISPs). I believe Haskell treats modeling the problem (and determining sig) as the hard part and it usually means implementations are “simple and obvious” (to those that really know the stdlib). Typed holes in purescript did wonders for me when I was learning (though it didn’t help with heavy aliasing)\n\n3. I really like the idea of keeping the learning curve flat, but there is always a dropoff. Also, good pedagogy goes a long way towards keeping learning curves flat as a crutch to design.\n4. If you are really focused on developing a first language, I recommend you actually practice it on people, document\/record the pedagogy (ethically), and keep track of how people are actually modeling the problem in their head as they build conceptions, test hypothesis, and develop the dreaded misconceptions. It works for frameworks too :) Also google scholar the rainfall problem :)",
        "user": "UN57U8V53",
        "ts": "1591124530.285200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3447742b735b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-09\/753296041488_3447742b735b104a7ff2_72.png",
            "first_name": "",
            "real_name": "Don Abrams",
            "display_name": "Don Abrams",
            "team": "T5TCAFTA9",
            "name": "donabrams",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UN57U8V53",
            "ts": "1591124545.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "usT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A few comments on this thread.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "This presentation ignores a lot of research on visual programming languages. Specifically there is a large focus in current computing education research on transitioning from a visual language to a text based one gradually (some with real quant and qual behind them)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Haskell’s currying exists because all functions take a single argument. But if you wanted to address the issue you mention, you could color each “type” in the signature and show the result under the type variable (with parens as boxes) so you can keep track (like rainbow paren for LISPs). I believe Haskell treats modeling the problem (and determining sig) as the hard part and it usually means implementations are “simple and obvious” (to those that really know the stdlib). Typed holes in purescript did wonders for me when I was learning (though it didn’t help with heavy aliasing)\n"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I really like the idea of keeping the learning curve flat, but there is always a dropoff. Also, good pedagogy goes a long way towards keeping learning curves flat as a crutch to design."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "If you are really focused on developing a first language, I recommend you actually practice it on people, document\/record the pedagogy (ethically), and keep track of how people are actually modeling the problem in their head as they build conceptions, test hypothesis, and develop the dreaded misconceptions. It works for frameworks too :) Also google scholar the rainfall problem :)"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU"
    }
]