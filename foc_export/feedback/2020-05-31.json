[
    {
        "client_msg_id": "24447a04-08a1-47a5-a302-f4b967e0ee72",
        "type": "message",
        "text": "<@UEQ6M68H0> Yes, I agree that it will be necessary to demonstrate its capabilities with sufficiently complex examples. In terms of the readability of Haskell, I do see the project moving beyond Haskell after Step 0 to a simpler language. Partially applied functions however, are something that a visual editor could make explicit. For example, ((+) 1) could be displayed as ((+) 1 O) where O represents the missing argument.\n\nOn a side note, I don't fully understand your criticism of currying. Are you talking about reading code that you know is correct, buggy code where you suspect some arguments are missing, or code you are in the middle of writing?  To paraphrase your argument, with currying you don't know if the type of (f x) is a plain value or a function. But that ambiguity exists in any language where functions can return functions.\n<@U0123H7JRDM> I'm presenting it as a research project, although if successful I could see it inspiring commercial projects. My goal is to create something general purpose, so right now I'm not targeting a specific domain. My plan is to start by dogfooding it by developing Glance using Glance, and once all of the obvious bugs are fixed pick a substantial project to implement.",
        "user": "UP3FH4CLU",
        "ts": "1590911061.260100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g82383c24412",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/82383c2441228c52f5d8ec17161dc031.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "",
            "real_name": "Robbie Gleichman",
            "display_name": "Robbie Gleichman",
            "team": "T5TCAFTA9",
            "name": "rgleichman",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DSvTW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " Yes, I agree that it will be necessary to demonstrate its capabilities with sufficiently complex examples. In terms of the readability of Haskell, I do see the project moving beyond Haskell after Step 0 to a simpler language. Partially applied functions however, are something that a visual editor could make explicit. For example, ((+) 1) could be displayed as ((+) 1 O) where O represents the missing argument.\n\nOn a side note, I don't fully understand your criticism of currying. Are you talking about reading code that you know is correct, buggy code where you suspect some arguments are missing, or code you are in the middle of writing?  To paraphrase your argument, with currying you don't know if the type of (f x) is a plain value or a function. But that ambiguity exists in any language where functions can return functions.\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U0123H7JRDM"
                            },
                            {
                                "type": "text",
                                "text": " I'm presenting it as a research project, although if successful I could see it inspiring commercial projects. My goal is to create something general purpose, so right now I'm not targeting a specific domain. My plan is to start by dogfooding it by developing Glance using Glance, and once all of the obvious bugs are fixed pick a substantial project to implement."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU"
    },
    {
        "client_msg_id": "ea73f901-e73d-430f-9ea1-dadc3507baa1",
        "type": "message",
        "text": "<@UP3FH4CLU> thanks for sharing these graphics! I know how much work it can be to put diagrams like that together. I have similar feelings as <@UEQ6M68H0>, in that I would worry the examples are too low level. The majority of \"business people\" (for example) who need to program are not doing complex math with reducers or functional programming. So, I would really conceptualize the kinds of problems you want your language users to be able to solve. At my company, we are building a textual language which operates at a far higher level like\n`once daily (at: 9am):`\n    `(@Postmates) (send) (item description: \"Any kind of flowers\") (to address: üìç324 Madison)`\nParens would not be necessary in our editor and our language is a bit richer allowing you to use things like <http:\/\/like%20this|links> to reference variables.",
        "user": "UFPPABQ7P",
        "ts": "1590963647.260500",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cb9d79e2bebc",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-05-09\/631538186901_cb9d79e2bebc09100b3f_72.jpg",
            "first_name": "Cole",
            "real_name": "Cole Lawrence",
            "display_name": "Cole",
            "team": "T5TCAFTA9",
            "name": "colelawr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UFPPABQ7P",
            "ts": "1590963811.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H5s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": " thanks for sharing these graphics! I know how much work it can be to put diagrams like that together. I have similar feelings as "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": ", in that I would worry the examples are too low level. The majority of \"business people\" (for example) who need to program are not doing complex math with reducers or functional programming. So, I would really conceptualize the kinds of problems you want your language users to be able to solve. At my company, we are building a textual language which operates at a far higher level like\n"
                            },
                            {
                                "type": "text",
                                "text": "once daily (at: 9am):",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "    (@Postmates) (send) (item description: \"Any kind of flowers\") (to address: üìç324 Madison)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nParens would not be necessary in our editor and our language is a bit richer allowing you to use things like "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/like%20this",
                                "text": "links"
                            },
                            {
                                "type": "text",
                                "text": " to reference variables."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU"
    },
    {
        "client_msg_id": "eab58144-de26-4600-8955-e7776a58d7ae",
        "type": "message",
        "text": "<@UP3FH4CLU> I cannot think of an example in any of the 20 sample programs i have written so far, where currying could be applied. Ambiguity is the enemy of comprehension, and in any language where you can't tell if something is a simple function call or instead a function that returns a function without checking the tail end of the parameter list, creates a difficulty in reading that is just not worth it. It means you have to know when reading the exact parameter list of every function call you see. Given that larger programs are mostly function calls, this imposes a significant memory burden on the reader. The idea of long sequences of positional parameters is an archaic notion dating back to FORTRAN, and is also not readable. I adopted the Smalltalk practice of using optional named parameters, which was also used in Objective-C. It is much more readable. Always a tradeoff between full named parameters and positional; i have adopted a mixed approach because they can get annoying.",
        "user": "UEQ6M68H0",
        "ts": "1590970123.261200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kvTQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": " I cannot think of an example in any of the 20 sample programs i have written so far, where currying could be applied. Ambiguity is the enemy of comprehension, and in any language where you can't tell if something is a simple function call or instead a function that returns a function without checking the tail end of the parameter list, creates a difficulty in reading that is just not worth it. It means you have to know when reading the exact parameter list of every function call you see. Given that larger programs are mostly function calls, this imposes a significant memory burden on the reader. The idea of long sequences of positional parameters is an archaic notion dating back to FORTRAN, and is also not readable. I adopted the Smalltalk practice of using optional named parameters, which was also used in Objective-C. It is much more readable. Always a tradeoff between full named parameters and positional; i have adopted a mixed approach because they can get annoying."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    }
]