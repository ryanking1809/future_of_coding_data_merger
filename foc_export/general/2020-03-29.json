[
    {
        "type": "message",
        "text": "<@UAVCC2X70> free anytime this week. how about yourself? <@UD6EXQVM0> you're more than welcome to join too",
        "user": "U01003H81UM",
        "ts": "1585465775.017800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bf5b5671ecea",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-03-14\/1000271226192_bf5b5671eceac85250cf_72.png",
            "first_name": "",
            "real_name": "ikrima",
            "display_name": "ikrima",
            "team": "T5TCAFTA9",
            "name": "e228",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "client_msg_id": "260a0e39-c9dd-4955-b6df-5480be7f98ed",
        "type": "message",
        "text": "<@UCGAK10LS> what exactly do you mean saying that Datalog in particular shows that subroutines are not an intrinsic part of all programming?  Let me throw out some ideas that you might want ot latch on to.  Certainly Datalog rules induce a tree-ish structure on how some facts are inferred from others.  This inference structure has strong parallels to a trace of subroutine calls and returns.  Now in a pure (functionally) Datalog, inference has no temporal component: can happen in any order, results can be precomputed or cached, who cares.  Imperative programs, in contrast, are best understood within a strict call return tree — what with shared state threads immediately giving rise to endless trouble.  Finally, good old fashioned cut Prolog has a strict search strategy, which to me at least, feels practically identical to imperative call\/return albeit enriched.",
        "user": "UA14TGLTC",
        "ts": "1585468955.018100",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6i=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " what exactly do you mean saying that Datalog in particular shows that subroutines are not an intrinsic part of all programming?  Let me throw out some ideas that you might want ot latch on to.  Certainly Datalog rules induce a tree-ish structure on how some facts are inferred from others.  This inference structure has strong parallels to a trace of subroutine calls and returns.  Now in a pure (functionally) Datalog, inference has no temporal component: can happen in any order, results can be precomputed or cached, who cares.  Imperative programs, in contrast, are best understood within a strict call return tree — what with shared state threads immediately giving rise to endless trouble.  Finally, good old fashioned cut Prolog has a strict search strategy, which to me at least, feels practically identical to imperative call\/return albeit enriched."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "type": "message",
        "text": "<@UA14TGLTC> The standard evaluation strategy for Datalog programs is known as \"semi-naive evaluation\". I've attached the algorithm to this message. Notably, the only function call is \"Eval\/Eval-incr\", which is just a lookup table for a sequence of relational algebra (RA) operations for the current rule (the program code) being executed. The RA operations are applied to sets of input tuples to produce a set of output tuples. So Datalog evaluation requires no call stack! Accordingly, it's not helpful to think about subroutines when reading, writing, or executing Datalog programs. It's easy (and recommended) to think of Datalog programs as a bunch of rules that \"fire\" in response to inputs to compute an output (a deduction), for as long as new deductions can be made.",
        "files": [
            {
                "id": "F010N6PQCH1",
                "created": 1585470341,
                "timestamp": 1585470341,
                "name": "IMG_044A83AAC0A9-1.jpeg",
                "title": "IMG_044A83AAC0A9-1.jpeg",
                "mimetype": "image\/jpeg",
                "filetype": "jpg",
                "pretty_type": "JPEG",
                "user": "UCGAK10LS",
                "editable": false,
                "size": 287050,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https:\/\/files.slack.com\/files-pri\/T5TCAFTA9-F010N6PQCH1\/img_044a83aac0a9-1.jpeg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "url_private_download": "https:\/\/files.slack.com\/files-pri\/T5TCAFTA9-F010N6PQCH1\/download\/img_044a83aac0a9-1.jpeg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_64": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_64.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_80": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_80.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_360": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_360.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_360_w": 360,
                "thumb_360_h": 187,
                "thumb_480": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_480.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_480_w": 480,
                "thumb_480_h": 249,
                "thumb_160": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_160.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_720": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_720.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_720_w": 720,
                "thumb_720_h": 373,
                "thumb_800": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_800.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_800_w": 800,
                "thumb_800_h": 415,
                "thumb_960": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_960.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_960_w": 960,
                "thumb_960_h": 498,
                "thumb_1024": "https:\/\/files.slack.com\/files-tmb\/T5TCAFTA9-F010N6PQCH1-0922bc5886\/img_044a83aac0a9-1_1024.jpg?t=xoxe-197418537349-1220335257046-1227067770482-88f226025a2db8e34ac513e918d80320",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 531,
                "image_exif_rotation": 1,
                "original_w": 1925,
                "original_h": 998,
                "thumb_tiny": "AwAYADDQIOfvGgAnqTSkc5oB570AL+dLijNGaADFGKM0UANOc9KAOadRQAUUUUAFFFFAH\/\/Z",
                "permalink": "https:\/\/futureofcoding.slack.com\/files\/UCGAK10LS\/F010N6PQCH1\/img_044a83aac0a9-1.jpeg",
                "permalink_public": "https:\/\/slack-files.com\/T5TCAFTA9-F010N6PQCH1-4e352b305c",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9eNeP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " The standard evaluation strategy for Datalog programs is known as \"semi-naive evaluation\". I've attached the algorithm to this message. Notably, the only function call is \"Eval\/Eval-incr\", which is just a lookup table for a sequence of relational algebra (RA) operations for the current rule (the program code) being executed. The RA operations are applied to sets of input tuples to produce a set of output tuples. So Datalog evaluation requires no call stack! Accordingly, it's not helpful to think about subroutines when reading, writing, or executing Datalog programs. It's easy (and recommended) to think of Datalog programs as a bunch of rules that \"fire\" in response to inputs to compute an output (a deduction), for as long as new deductions can be made."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UCGAK10LS",
        "display_as_bot": false,
        "ts": "1585470347.018300",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585470616.000000"
        },
        "client_msg_id": "d122ad83-56dc-4362-b7b5-474c1d567b6a",
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "789ab61c-f893-4e25-9e74-21becaa0385a",
        "type": "message",
        "text": "Prolog on the other hand (as you point out), was designed around a specific (convoluted) evaluation strategy involving imperative functions and call\/return traversal. I don't have any good things to say about Prolog, beyond its role in inspiring better alternatives.",
        "user": "UCGAK10LS",
        "ts": "1585470495.018800",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585470586.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IWXVN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Prolog on the other hand (as you point out), was designed around a specific (convoluted) evaluation strategy involving imperative functions and call\/return traversal. I don't have any good things to say about Prolog, beyond its role in inspiring better alternatives."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "416c1dee-cc15-406d-b680-901acfc27e68",
        "type": "message",
        "text": "Weird that it discusses the obvious elephant in the room, FRP, only towards the end, and then in the form of non-native reactive frameworks, not actual FRP languages, then dismisses it as being costly\/complex\/non-native.. seems the authors have some research to catch up with",
        "user": "UHDQ62M4P",
        "ts": "1585497243.019400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jJ\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Weird that it discusses the obvious elephant in the room, FRP, only towards the end, and then in the form of non-native reactive frameworks, not actual FRP languages, then dismisses it as being costly\/complex\/non-native.. seems the authors have some research to catch up with"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "082a2953-4468-4780-8716-ab041ed529ca",
        "type": "message",
        "text": "that said, doing something FRP-like in an imperative context seems valuable to me, though I'd like to see it at a larger scale: functions that map intrinsic data to derived data (like functional relation programming - different from functional reactive programming)",
        "user": "UHDQ62M4P",
        "ts": "1585497362.019600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NvU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that said, doing something FRP-like in an imperative context seems valuable to me, though I'd like to see it at a larger scale: functions that map intrinsic data to derived data (like functional relation programming - different from functional reactive programming)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "d164c107-1501-41e2-8223-2dd0355eadd0",
        "type": "message",
        "text": "<@UCUSW7WVD> I'm also having some difficulty understanding the paper, both the problem it sees with call\/return and the suggested solution. Here's my sense of it:\n\nMost languages assume functions or subroutines (call\/return) as the smallest unit of organization.\n\nYou can use call\/return to implement other organizational schemes, like dataflow or data-binding.\n\nBut if you do that,\n• you still need to think in terms of call\/return when deeply analyzing the system — when debugging, or doing other similar things that require mechanical sympathy.\n• the character of call\/return set the character of the language, affecting all code written with it.\n\nInstead, it would be better if a programming language had additional kinds of organization at the fundamental \/ smallest \/ bottom level.",
        "user": "UC2A2ARPT",
        "ts": "1585501213.020200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1585501259.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ttjo2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I'm also having some difficulty understanding the paper, both the problem it sees with call\/return and the suggested solution. Here's my sense of it:\n\nMost languages assume functions or subroutines (call\/return) as the smallest unit of organization.\n\nYou can use call\/return to implement other organizational schemes, like dataflow or data-binding.\n\nBut if you do that,\n• you still need to think in terms of call\/return when deeply analyzing the system — when debugging, or doing other similar things that require mechanical sympathy.\n• the character of call\/return set the character of the language, affecting all code written with it.\n\nInstead, it would be better if a programming language had additional kinds of organization at the fundamental \/ smallest \/ bottom level."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e1bcee49-3730-4a5c-8b8f-0781c4265645",
        "type": "message",
        "text": "<@UEQ6M68H0>\n\nYou said:\n\n&gt; Call\/return (subroutines) are an intrinsic part of all programming\nFrom the paper:\n\n&gt; One of the reasons programming is so hard and requires seemingly excessive amounts of engineering is that the (linguistic) tools we use no longer match the systems we are expected to build using those tools.\n&gt; However, the assumption that this particular architectural style is the only one that amounts to “programming” is so deeply entrenched that we tend to describe alternatives as _not-programming_, so _modeling, configuring or architectural-description_.\n\/ Objection! meme \/",
        "user": "UC2A2ARPT",
        "ts": "1585501447.021400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7ad",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": "\n\nYou said:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Call\/return (subroutines) are an intrinsic part of all programming"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFrom the paper:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of the reasons programming is so hard and requires seemingly excessive amounts of engineering is that the (linguistic) tools we use no longer match the systems we are expected to build using those tools.\nHowever, the assumption that this particular architectural style is the only one that amounts to “programming” is so deeply entrenched that we tend to describe alternatives as "
                            },
                            {
                                "type": "text",
                                "text": "not-programming",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", so "
                            },
                            {
                                "type": "text",
                                "text": "modeling, configuring or architectural-description",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\/ Objection! meme \/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "5cb74446-ae72-4fa7-b58d-7d9ac8cc1b8a",
        "type": "message",
        "text": "<@UC2A2ARPT> I see. So it doesn't matter that these additional kinds of organization are built out of call\/ret at the lowest level, because he's taking the hit for the rest of us?",
        "user": "UCUSW7WVD",
        "ts": "1585501648.021600",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "blyT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " I see. So it doesn't matter that these additional kinds of organization are built out of call\/ret at the lowest level, because he's taking the hit for the rest of us?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "ABEE3D46-5AC6-4D1F-827E-F8F9091B5D35",
        "type": "message",
        "text": "Yeah, pretty much. As long as you never need to think about things lower down than the language primitives. * tugs collar *\n\nAt least, that's my read. Not sure I got the right takeaways.",
        "user": "UC2A2ARPT",
        "ts": "1585501844.023700",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1585502131.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2la9i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, pretty much. As long as you never need to think about things lower down than the language primitives. * tugs collar *\n\nAt least, that's my read. Not sure I got the right takeaways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "19dce77d-8f2d-4bdb-966b-efe95047af59",
        "type": "message",
        "text": "Struggling with the strange syntax gave me greater empathy for readers of my own paper with its own strange syntax.",
        "user": "UCUSW7WVD",
        "ts": "1585513258.024400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "urm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Struggling with the strange syntax gave me greater empathy for readers of my own paper with its own strange syntax."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "beers",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "07dc1203-ee8a-4bbe-8d75-75676cb7c1ef",
        "type": "message",
        "text": "I don't care what language or system you use, you will invariably find repeated sequences in whatever you are building. A macro system allows you to inline what would have been a function call\/return block. Macros have positives - they are faster than function calls, and can be customized, so they are more powerful in a way. Macros are used extensively in assembler, and with enough macros Microsoft Assembler can look a lot like a higher level language. But macros make debugging much harder, because now you can't step through your source code, but instead have to step through the generated source code, and thus you now have a second form of your source code (the output of the pre-processor) to consider. The other drawback of highly nested macros is that your source code size could explode geometrically. It all depends on how deeply nested the macros get. In some sense, you can think of a LISP program as a giant pile of nested macros, which makes them super powerful and also super hard to read.\n\nYou can play games with your language primitives, and pretend you don't have IF statements, or subroutines with CALL\/RETURN, or LOOPS, etc., but it must at the end of the day devolve into the instruction set of the 50 year old computer we are using, which has only a very tiny set of atomic operations such as a 2-way branch, a n-way branch, call\/return, arithmetic, etc.\n\nRe-use of some kind of formatting or methodology is desirable (if not mandatory), and i don't care what you call it, it will be some kind of subroutine that is called, and what goes down into a sub-function must come back up. This isn't tyranny, it is like arithmetic, a fact of existence that sub-patterns will be identified, coded, and re-used extensively. The more sub-patterns you can identify, the shorter your programs will be. All great programmers code in exactly the same way; instinctively seeking the minimal surface area of the program, by balancing number of sub-functions, and placing them into layers so that they have as few interconnections as possible.",
        "user": "UEQ6M68H0",
        "ts": "1585522725.024900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1585522851.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IsfUh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't care what language or system you use, you will invariably find repeated sequences in whatever you are building. A macro system allows you to inline what would have been a function call\/return block. Macros have positives - they are faster than function calls, and can be customized, so they are more powerful in a way. Macros are used extensively in assembler, and with enough macros Microsoft Assembler can look a lot like a higher level language. But macros make debugging much harder, because now you can't step through your source code, but instead have to step through the generated source code, and thus you now have a second form of your source code (the output of the pre-processor) to consider. The other drawback of highly nested macros is that your source code size could explode geometrically. It all depends on how deeply nested the macros get. In some sense, you can think of a LISP program as a giant pile of nested macros, which makes them super powerful and also super hard to read.\n\nYou can play games with your language primitives, and pretend you don't have IF statements, or subroutines with CALL\/RETURN, or LOOPS, etc., but it must at the end of the day devolve into the instruction set of the 50 year old computer we are using, which has only a very tiny set of atomic operations such as a 2-way branch, a n-way branch, call\/return, arithmetic, etc.\n\nRe-use of some kind of formatting or methodology is desirable (if not mandatory), and i don't care what you call it, it will be some kind of subroutine that is called, and what goes down into a sub-function must come back up. This isn't tyranny, it is like arithmetic, a fact of existence that sub-patterns will be identified, coded, and re-used extensively. The more sub-patterns you can identify, the shorter your programs will be. All great programmers code in exactly the same way; instinctively seeking the minimal surface area of the program, by balancing number of sub-functions, and placing them into layers so that they have as few interconnections as possible."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "6e97572f-390b-44ac-bfcb-7ed7ca72ad51",
        "type": "message",
        "text": "The things you said about macros only apply to textual\/text-file languages wherein the expansion of a macro means inserting a bunch of text inline and feeding the result into a naive compiler. If you throw away implementation preconceptions and just think of a (parameterized) macro as \"here is a pattern for achieving a behaviour, now fill in the blanks\", then no problems immediately arise. The concept is not problematic, but realisations of it can be.",
        "user": "UCGAK10LS",
        "ts": "1585523408.025200",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585524158.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MKo5h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The things you said about macros only apply to textual\/text-file languages wherein the expansion of a macro means inserting a bunch of text inline and feeding the result into a naive compiler. If you throw away implementation preconceptions and just think of a (parameterized) macro as \"here is a pattern for achieving a behaviour, now fill in the blanks\", then no problems immediately arise. The concept is not problematic, but realisations of it can be."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "ea3e2016-a523-4a90-8754-92f0c591ba55",
        "type": "message",
        "text": "And I disagree with the rest of your assertions about call\/return, but I already gave that counter-argument earlier in the thread.",
        "user": "UCGAK10LS",
        "ts": "1585523492.025400",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "770c193fd379",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-17\/1092364753072_770c193fd379ebbced3f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585524046.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6L5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And I disagree with the rest of your assertions about call\/return, but I already gave that counter-argument earlier in the thread."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "0882351e-baeb-4823-8c79-d57f0ae06d56",
        "type": "message",
        "text": "This weekend turned out very busy (I'll answer David's questions once I can squeeze time back into my schedule -- working from home with kids out of school and a bad internet connection, and taking time out to fix it, has been interesting). How about this upcoming weekend?",
        "user": "UAVCC2X70",
        "ts": "1585539994.025900",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1585540114.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JPs3g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This weekend turned out very busy (I'll answer David's questions once I can squeeze time back into my schedule -- working from home with kids out of school and a bad internet connection, and taking time out to fix it, has been interesting). How about this upcoming weekend?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    }
]